
#pragma kernel CSMain

RWTexture2D<float4> Result;
RWTexture2D<float1> Mask;
RWTexture2D<float1> CameraDepth;

float DepthThresholdLow, DepthThresholdHigh;
uint Width, Height;

void SetMask (uint3 id)
{
    float2 dimensions = id.xy / float2(Width,Height);

    float depthValue = CameraDepth[id.xy];

    uint mask = (depthValue < DepthThresholdLow || depthValue > DepthThresholdHigh) ? 0 : 1;

    Mask[id.xy] = float1(mask);
}

bool ComparePixels(float2 pixelAID, float2 pixelBID)
{
    // Calculate luminance using RGB values
    float luminanceA = (0.2126 * Result[pixelAID].r + 0.7152 * Result[pixelAID].g + 0.0722 * Result[pixelAID].b);
    float luminanceB = (0.2126 * Result[pixelBID].r + 0.7152 * Result[pixelBID].g + 0.0722 * Result[pixelBID].b);

    return luminanceA < luminanceB && Mask[pixelAID] == 1 && Mask[pixelBID] == 1;
}

void SwapPixels(uint2 pixelAID, uint2 pixelBID)
{
    if (ComparePixels(pixelAID, pixelBID))
    {
        float4 temp = Result[pixelAID];
        Result[pixelAID] = Result[pixelBID];
        Result[pixelBID] = temp;
    }
}

void SimpleSort(uint2 uv)
{
    for (uint h = 0; h < Height; h+2)
    {
        uint2 pixelAID = uint2(uv.x, h);
        uint2 pixelBID = uint2(uv.x, h+1);

        SwapPixels(pixelAID, pixelBID);
    }
}

void FlipSort()
{
}

void SlideSort()
{

}

void Sort(uint2 uv)
{
    SimpleSort(uv);
    // n represents the cycle it is currently on
    for (uint n = 0; n<Height/2; n++)
    {
        FlipSort();
        SlideSort();
    }
}

[numthreads(16,16,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= Width || id.y >= Height)
        return;

    SetMask(id);

    GroupMemoryBarrierWithGroupSync();

    uint2 uv = id.xy;
    Sort(uv);
}

